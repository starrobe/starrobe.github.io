import{_ as c}from"./ValaxyMain.vue_vue_type_style_index_0_lang-d8ab152d.js";import{_ as u,u as h,p as f,c as m,w as t,o as p,a as e,b as a,d as o,r as l,e as _}from"./app-2781ddff.js";import"./YunFooter.vue_vue_type_script_setup_true_lang-e8642e2c.js";import"./YunCard.vue_vue_type_script_setup_true_lang-7e7da48c.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-ebad1ef6.js";const X=JSON.parse('{"title":"MESI协议以及内存屏障","description":"","frontmatter":{"layout":"post","title":"MESI协议以及内存屏障","date":"2023-08-10T12:11:41.000Z","categories":"笔记","tags":["并发编程"]},"headers":[{"level":3,"title":"缓存一致性","slug":"缓存一致性","link":"#缓存一致性","children":[]},{"level":3,"title":"MESI协议","slug":"mesi协议","link":"#mesi协议","children":[]},{"level":3,"title":"内存屏障","slug":"内存屏障","link":"#内存屏障","children":[]}],"relativePath":"pages/posts/mesi.md","path":"/home/runner/work/valaxy/valaxy/pages/posts/mesi.md","lastUpdated":1692888211000}'),r=JSON.parse('{"title":"MESI协议以及内存屏障","description":"","frontmatter":{"layout":"post","title":"MESI协议以及内存屏障","date":"2023-08-10T12:11:41.000Z","categories":"笔记","tags":["并发编程"]},"headers":[{"level":3,"title":"缓存一致性","slug":"缓存一致性","link":"#缓存一致性","children":[]},{"level":3,"title":"MESI协议","slug":"mesi协议","link":"#mesi协议","children":[]},{"level":3,"title":"内存屏障","slug":"内存屏障","link":"#内存屏障","children":[]}],"relativePath":"pages/posts/mesi.md","path":"/home/runner/work/valaxy/valaxy/pages/posts/mesi.md","lastUpdated":1692888211000}'),g={name:"pages/posts/mesi.md",data(){return{data:r,frontmatter:r.frontmatter,$frontmatter:r.frontmatter}},setup(){const n=h();n.meta.frontmatter=Object.assign(n.meta.frontmatter,r.frontmatter),f("pageData",r)}},C={id:"缓存一致性",tabindex:"-1"},y=e("p",null,"由于L1/L2 Cache是多个核心各自独有的，会带来缓存一致性的问题",-1),b=e("blockquote",null,[e("p",null,"CPU Cache是由多个Cache Line组成，Cache Line也是CPU从内存读取数据的基本单位")],-1),S=e("p",null,[e("img",{src:"https://starrobe.oss-cn-beijing.aliyuncs.com/blog/cpu.png",alt:"cpu"})],-1),B={id:"mesi协议",tabindex:"-1"},x=e("ul",null,[e("li",null,"Modified，已修改"),e("li",null,"Exclusive，独占"),e("li",null,"Shared，共享"),e("li",null,"Invalidated，已失效")],-1),A=e("p",null,[e("img",{src:"https://starrobe.oss-cn-beijing.aliyuncs.com/blog/memory1.png",alt:"cpu memory1"})],-1),v=e("blockquote",null,[e("p",null,"CPU要从主存读写数据，需要向总线发起事务(读事务或写事务)来从主存读取或者写入数据")],-1),P=e("p",null,"假设有两个CPU，A与B，内存中n的值为1",-1),U=e("table",null,[e("thead",null,[e("tr",null,[e("th",{style:{"text-align":"left"}},"操作"),e("th",{style:{"text-align":"center"}},"CPU A Cache 中数据的状态"),e("th",{style:{"text-align":"center"}},"CPU B Cache 中的数据的状态")])]),e("tbody",null,[e("tr",null,[e("td",{style:{"text-align":"left"}},"1. B读取n时，此时Cache B中没有，从主存中读取"),e("td",{style:{"text-align":"center"}},"-"),e("td",{style:{"text-align":"center"}},"n变为独占状态")]),e("tr",null,[e("td",{style:{"text-align":"left"}},"2. A获取n时，此时Cache A中没有，而B收到总线通知，将n拷贝到Cache A"),e("td",{style:{"text-align":"center"}},"n变为共享状态"),e("td",{style:{"text-align":"center"}},"n变为共享状态")]),e("tr",null,[e("td",{style:{"text-align":"left"}},"3. A要修改n的值时，通过总线发送失效指令，A收到B的ACK后才能进行修改"),e("td",{style:{"text-align":"center"}},"n变为独占状态"),e("td",{style:{"text-align":"center"}},"n变为失效状态")]),e("tr",null,[e("td",{style:{"text-align":"left"}},"4. A修改完毕后，如令n=2"),e("td",{style:{"text-align":"center"}},"n变为已修改状态"),e("td",{style:{"text-align":"center"}},"n变为失效状态")]),e("tr",null,[e("td",{style:{"text-align":"left"}},"5. 当B再次获取n时，发现自己是失效的，需要向A请求"),e("td",{style:{"text-align":"center"}},"n变为共享状态"),e("td",{style:{"text-align":"center"}},"n变为共享状态")])])],-1),$={id:"store-buffer",tabindex:"-1"},k=e("p",null,"通过MESI保证了缓存一致性，即保证A与B缓存中的数据一致。但A的每次修改都需要等待B的ACK，会占用CPU的 利用率，因此引用Store Buffer",-1),M=e("p",null,"当CPU发送失效指令后，将修改的数据放入Store Buffer，然后执行其他命令。当其他CPU都响应了ACK后， CPU Cache再从Store Buffer读取数据",-1),E={id:"store-forward",tabindex:"-1"},I=e("p",null,"当修改后的数据还在Store Buffer，Cache中的数据仍是旧值时，CPU如果接到读取指令，会从Cache中读取到旧值。 因此，当CPU读取数据时，会先查看Store Buffer中有没有，如果有则直接读取Store Buffer里的值，如果没有才 读取Cache中的数据，这便是Store Forward",-1),w={id:"失效队列",tabindex:"-1"},K=e("p",null,"所有的数据的修改都会存在Store Buffer中，而当Store Buffer满了后，CPU仍然需要等待ACK后才能进行修改。 当其他CPU收到失效指令后，要先将数据置为失效状态，然后再响应ACK，而此时CPU可能很忙，不能及时处理",-1),L=e("p",null,"因此加入失效队列，当CPU收到失效指令时，将其放入失效队列中，并直接返回ACK，等到空闲时再处理队列中的消息",-1),N=e("p",null,[e("img",{src:"https://starrobe.oss-cn-beijing.aliyuncs.com/blog/memory2.png",alt:"cpu memory2"})],-1),j=e("blockquote",null,[e("p",null,"CPU的指令乱序执行是由Store Buffer以及失效队列造成的"),e("p",null,"假设缓存A，B中都有a，b。当CPU A先修改a后修改b时，可能会先收到b的ACK再收到a的ACK，即先修改b再修改a")],-1),V={id:"内存屏障",tabindex:"-1"},q=e("p",null,"Store Buffer不能保证最新的修改更新到主存，而CPU没有及时的读取失效队列的消息导致 缓存数据没能及时变为失效状态，而直接被读取",-1),O=e("p",null,"内存屏障简单的说就是禁用Store Buffer以及失效队列",-1),T=e("ul",null,[e("li",null,"在写入数据时，保证所有写入指令都执行完毕(Store Buffer都写入到Cache)"),e("li",null,"在读取数据时，保证所有失效队列的消息已经完成")],-1);function D(n,F,J,Z,i,R){const s=_,d=c;return p(),m(d,{frontmatter:i.frontmatter,data:i.data},{"main-content-md":t(()=>[e("h3",C,[a("缓存一致性 "),o(s,{class:"header-anchor",href:"#缓存一致性","aria-hidden":"true"},{default:t(()=>[a("#")]),_:1})]),y,b,S,e("h3",B,[a("MESI协议 "),o(s,{class:"header-anchor",href:"#mesi协议","aria-hidden":"true"},{default:t(()=>[a("#")]),_:1})]),x,A,v,P,U,e("h4",$,[a("Store Buffer "),o(s,{class:"header-anchor",href:"#store-buffer","aria-hidden":"true"},{default:t(()=>[a("#")]),_:1})]),k,M,e("h4",E,[a("Store Forward "),o(s,{class:"header-anchor",href:"#store-forward","aria-hidden":"true"},{default:t(()=>[a("#")]),_:1})]),I,e("h4",w,[a("失效队列 "),o(s,{class:"header-anchor",href:"#失效队列","aria-hidden":"true"},{default:t(()=>[a("#")]),_:1})]),K,L,N,j,e("h3",V,[a("内存屏障 "),o(s,{class:"header-anchor",href:"#内存屏障","aria-hidden":"true"},{default:t(()=>[a("#")]),_:1})]),q,O,T]),"main-header":t(()=>[l(n.$slots,"main-header")]),"main-header-after":t(()=>[l(n.$slots,"main-header-after")]),"main-nav":t(()=>[l(n.$slots,"main-nav")]),"main-content":t(()=>[l(n.$slots,"main-content")]),"main-content-after":t(()=>[l(n.$slots,"main-content-after")]),"main-nav-before":t(()=>[l(n.$slots,"main-nav-before")]),"main-nav-after":t(()=>[l(n.$slots,"main-nav-after")]),comment:t(()=>[l(n.$slots,"comment")]),footer:t(()=>[l(n.$slots,"footer")]),aside:t(()=>[l(n.$slots,"aside")]),"aside-custom":t(()=>[l(n.$slots,"aside-custom")]),default:t(()=>[l(n.$slots,"default")]),_:3},8,["frontmatter","data"])}const Y=u(g,[["render",D]]);export{X as __pageData,Y as default};
